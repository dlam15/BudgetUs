Index: app/src/main/java/com/example/budgetus/User.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.budgetus;\r\nimport java.util.*; \r\nimport java.io.*;\r\n\r\npublic class User\r\n{\r\n\tprivate String name;\r\n\tprivate String email;\r\n\tprivate String school;\r\n\tprivate String username;\r\n\tprivate String password;\r\n\tprivate Map<Integer, String> groups;\r\n\r\n\r\n\tpublic User(String name, String email, String school, String username, String password)\r\n\t{\r\n\t\tthis.name = name;\r\n\t\tthis.email = email;\r\n\t\tthis.school = school;\r\n\t\tthis.username = username;\r\n\t\tthis.password = password;\r\n    \t\tgroups = new HashMap<>();\r\n  }\r\n\t\r\n\tpublic boolean updateName(String name){\r\n\t\tthis.name = name;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic boolean updateEmail(String email){\r\n\t\tthis.email = email;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic boolean updatePassword(String password){\r\n\t\tthis.password = password;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic boolean updateSchool(String school){\r\n\t\tthis.school = school;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic boolean updateStatus(int groupID, String status){\r\n\t\tif(groups.containsKey(groupID)){\r\n\t\t\tfor (Map.Entry<Integer, String> tmp : groups.entrySet()){\r\n\t\t\t\tif(tmp.getKey() == groupID){\r\n\t\t\t\t\ttmp.setValue(status);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpublic String getName(){\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\tpublic String getEmail(){\r\n\t\treturn this.email;\r\n\t}\r\n\r\n\tpublic String getSchool(){\r\n\t\treturn this.school;\r\n\t}\r\n\r\n\tpublic String getUsername(){\r\n\t\treturn this.username;\r\n\t}\r\n\r\n\tpublic String getPassword(){\r\n\t\treturn this.password;\r\n\t}\r\n\r\n\tpublic String getStatus(int groupID){\r\n\t\tif(groups.containsKey(groupID)){\r\n\t\t\tfor (Map.Entry<Integer, String> tmp : groups.entrySet()){\r\n\t\t\t\tif(tmp.getKey() == groupID){\r\n\t\t\t\t\treturn tmp.getValue();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic boolean updateGroups(int groupID, String status){\r\n\t\tif(groups.isEmpty()){\r\n\t\t\tgroups.put(groupID, status);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tif(!(groups.containsKey(groupID))) {\r\n\t\t\t\tgroups.put(groupID, status);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpublic void forgotPassword() {\r\n\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/budgetus/User.java	(revision 6976b305048ceaf218fde1429623f3b7a25e0294)
+++ app/src/main/java/com/example/budgetus/User.java	(date 1606164408453)
@@ -9,7 +9,7 @@
 	private String school;
 	private String username;
 	private String password;
-	private Map<Integer, String> groups;
+	private Map<Integer, String> groups=  new HashMap<>();;
 
 
 	public User(String name, String email, String school, String username, String password)
@@ -19,7 +19,7 @@
 		this.school = school;
 		this.username = username;
 		this.password = password;
-    		groups = new HashMap<>();
+
   }
 	
 	public boolean updateName(String name){
Index: app/src/main/java/com/example/budgetus/MainActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.budgetus;\r\n\r\nimport android.content.Intent;\r\nimport android.os.Bundle;\r\nimport android.view.View;\r\nimport android.widget.Button;\r\nimport android.widget.EditText;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\n\r\n;\r\n\r\n\r\n\r\npublic class MainActivity extends AppCompatActivity {\r\n\r\n    private EditText username;\r\n    private EditText password;\r\n    private Button loginbutton;\r\n    private Button registerbutton;\r\n    private UserRecord userRecord;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n\r\n\r\n        Button toRegBtn = (Button) findViewById(R.id.goToRegisterButton);\r\n        toRegBtn.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View view) {\r\n                launchRegisterActivity();\r\n            }\r\n        });\r\n        userRecord = new UserRecord();\r\n\r\n        //Theresa's\r\n         username = (EditText) findViewById(R.id.editUsername);\r\n         password = (EditText)findViewById(R.id.editPassword);\r\n         loginbutton = (Button) findViewById(R.id.btLogin);\r\n\r\n         loginbutton.setOnClickListener(new View.OnClickListener() {\r\n             @Override\r\n             public void onClick(View view) {\r\n                 String inputUser = username.getText().toString().trim();\r\n                 String inputPass = password.getText().toString().trim();\r\n                 validate(inputUser,inputPass);\r\n             }\r\n         });\r\n\r\n        // registerbutton.setOnClickListener(new Button.OnClickListener(){\r\n        //     public void onClick(View view) {\r\n        //         Intent registerPage = new Intent(MainActivity.this, Register.class);\r\n        //         startActivity(registerPage);\r\n        //     }\r\n        // });\r\n\r\n    }\r\n\r\n    private void launchRegisterActivity(){\r\n        Intent intent = new Intent(this, RegisterActivity.class);\r\n        startActivity(intent);\r\n    }\r\n\r\n     private void validate(String userName,String userPassword) {\r\n         //get username and password\r\n         String matchUser = \"admin\";\r\n         String matchPass = \"123\";\r\n         //If match go to next page\r\n         if (userRecord.checkUser(userName,userPassword)) {\r\n             Intent dashboardPage = new Intent(this, MainDashboard.class);\r\n             startActivity(dashboardPage);\r\n         }\r\n         else{\r\n             //Can create limited attempts at login\r\n            System.out.println(\"Failed to validate\");\r\n         }\r\n     }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/budgetus/MainActivity.java	(revision 6976b305048ceaf218fde1429623f3b7a25e0294)
+++ app/src/main/java/com/example/budgetus/MainActivity.java	(date 1606164408451)
@@ -17,7 +17,9 @@
     private EditText username;
     private EditText password;
     private Button loginbutton;
-    private Button registerbutton;
+    //private Button toRegBtn; teresa
+    //private Button forgotUsernamebutton;
+    //private Button forgotPasswordbutton;
     private UserRecord userRecord;
 
     @Override
@@ -33,13 +35,24 @@
                 launchRegisterActivity();
             }
         });
-        userRecord = new UserRecord();
+        userRecord = new UserRecord();//UserRecord userRecord = new UserRecord(MainActivity.this); matt
 
         //Theresa's
+        //Variables
          username = (EditText) findViewById(R.id.editUsername);
          password = (EditText)findViewById(R.id.editPassword);
          loginbutton = (Button) findViewById(R.id.btLogin);
+         //toRegBtn = (Button) findViewById(R.id.goToRegisterButton);
+         //forgotUsernamebutton = (Button) findViewById(R.id.btForgotUsername);
+         //forgotPasswordbutton = (Button) findViewById(R.id.btForgotPassword);
 
+        //Register Button teresa
+        //toRegBtn.setOnClickListener(new View.OnClickListener() {
+         //   @Override
+         //   public void onClick(View view) { launchRegisterActivity(); }
+        //});
+
+        //Login Button
          loginbutton.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View view) {
@@ -55,19 +68,48 @@
         //         startActivity(registerPage);
         //     }
         // });
+        /* teresa
+        //Forgot Username Button
+        forgotUsernamebutton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                launchForgotUsernameActivity();
+            }
+        });
 
+        //Forgot Password Button
+        forgotPasswordbutton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                launchForgotPasswordActivity();
+            }
+        });
+        */
     }
 
+    //Functions
     private void launchRegisterActivity(){
         Intent intent = new Intent(this, RegisterActivity.class);
         startActivity(intent);
     }
+/* teresa
+    private void launchForgotUsernameActivity(){
+        Intent intent = new Intent(this, forgotLogin.class);
+        startActivity(intent);
+    }
+
+    private void launchForgotPasswordActivity(){
+        Intent intent = new Intent(this, forgotLogin2.class);
+        startActivity(intent);
+    }
+*/
 
-     private void validate(String userName,String userPassword) {
+    private void validate(String userName,String userPassword) {
          //get username and password
          String matchUser = "admin";
          String matchPass = "123";
          //If match go to next page
+        //if (userName.equals(matchUser) && userPassword.equals(matchPass)) { teresa
          if (userRecord.checkUser(userName,userPassword)) {
              Intent dashboardPage = new Intent(this, MainDashboard.class);
              startActivity(dashboardPage);
Index: app/src/main/java/com/example/budgetus/UserRecord.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.budgetus;\r\n\r\nimport android.util.JsonReader;\r\nimport android.util.Log;\r\n\r\nimport java.util.Random;\r\n\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.security.SecureRandom;\r\nimport java.security.spec.InvalidKeySpecException;\r\nimport java.security.spec.KeySpec;\r\nimport java.util.Arrays;\r\n\r\nimport javax.crypto.SecretKeyFactory;\r\nimport javax.crypto.spec.PBEKeySpec;\r\nimport java.io.BufferedInputStream;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.net.HttpURLConnection;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Iterator;\r\nimport java.util.Properties;\r\nimport java.util.Set;\r\nimport javax.mail.*;\r\nimport javax.mail.internet.*;\r\nimport javax.activation.*;\r\n\r\n\r\n\r\npublic class UserRecord {\r\n\r\n    private Map<String, User> hashmap = new HashMap<String, User>(1000);\r\n\r\n    public UserRecord (){\r\n        try {\r\n            FileProcessor fp = new FileProcessor();\r\n            hashmap = fp.getUserMap();\r\n        }catch(Exception e){\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n\r\n    //TODO\r\n    //some tests\r\n    //additional functions\r\n    //correct communication between events firing, driver class, user class\r\n    //collision resolution vs username unavailable (see how many collisions from testing)\r\n\r\n\r\n    /*\r\n     * Add a new user to the hashmap. This is triggered when the user registers.\r\n     *\r\n     * To add a user, we first check that the email is not in use. This requires us to check all users.\r\n     *\r\n     * Then, we must make sure that the username is free as well. For a username to\r\n     * be available, it must not hash to an index that is already in use.\r\n     *\r\n     * Currently, if there is a collision (even if the username is not in use), we tell the user it\r\n     * is unavailable anyway. We could implement collision resolution instead (which is probably done by\r\n     * Java's hashmap already), but I will save that for a later time.\r\n     *\r\n     * If this username is available, we can then populate a new entry of our hashmap with the user object.\r\n     *\r\n     * I also print out a possible message the user should see when the User already exists - maybe pass this back to driver?\r\n     *\r\n     * @param user the user object containing the info for registration\r\n     * @return true if the user was registered correctly, false otherwise\r\n     */\r\n    public boolean addUser(User newUser) {\r\n        String username = newUser.getUsername();//obtain key from username hash function\r\n        if(getUserFromEmail(newUser.getEmail() )!= null){\r\n            System.out.println(\"Email already in use.\");\r\n            return false;//this is not a collision, but rather that the email is in use\r\n        }\r\n        if (hashmap.containsKey(username)) {//true if mapping for this key already exists - could be either a collision or that this username is taken\r\n            User existingUser = hashmap.get(username);\r\n            if(existingUser.getUsername() == username){//username actually in use, otherwise its just a collision\r\n                System.out.println(\"User already exists\");\r\n                return false;\r\n            }else{//could theoretically add user still, but we'd need some collision resolution\r\n                System.out.println(\"Collision\");\r\n                //see what java does here if you put anyway - can it retrieve correct one?\r\n            }\r\n        }else{\r\n            hashmap.put(username, newUser);\r\n            System.out.println(\"Success\");\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /*\r\n     * Get a user from the hashmap. Considering that all of the user objects are stored in the hashmap,\r\n     * we will need this function to actually obtain the object and work with it. Requires a username to\r\n     * access the object.\r\n     *\r\n     * @param username string username used to index the hashmap and return the object\r\n     * @return user the user object accessed from the hashmap with the username. null if user does not exist\r\n     */\r\n    public User getUser(String username){\r\n        return hashmap.get(username);\r\n    }\r\n\r\n\r\n    /*\r\n     * Get a user from the hashmap by their email. Will be used when the user forgets their username and during\r\n     * registration to make sure this email is not already in use. Needed as without username we cannot index, and need to O(N) search instead.\r\n     *\r\n     * We could modify this to get a user object by some of the other fields as well if needed.\r\n     *\r\n     * @param email string containing the email address we're searching all users for\r\n     * @return user the user object accessed from the hashmap with the email. null if user does not exist/cannot find email\r\n     */\r\n    public User getUserFromEmail(String email){\r\n        for(User userElement : hashmap.values()){\r\n            User currUser = userElement;\r\n            if(currUser.getEmail() == email) return currUser;\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    /*\r\n     * Remove a user from the hashmap. We check if they exist, and if they don't print out a message\r\n     * and return false instead. Again, I'd like a better place to put these messages.\r\n     *\r\n     * @param user user object to remove\r\n     * @return true on successful removal, false on unsuccessful removal\r\n     */\r\n    public boolean removeUser(User newUser){\r\n        String username = newUser.getUsername();\r\n        if(hashmap.remove(username) != null) return true;\r\n        System.out.println(\"User does not exist\");\r\n        return false;\r\n    }\r\n\r\n\r\n\r\n\r\n    /*\r\n     * Called when the user tries to log in. For a successful login, the username and password must match what was provided.\r\n     * As mentioned in my notes, passwords should not be stored as plaintext. So, we will probably be calling a function in User\r\n     * that uses a salt and hash to check this password with the salted and hashed one we have stored.\r\n     *\r\n     * We also have the ability to know if the username does not exist. We probably won't provide this info to the user in case\r\n     * they are not who they say they are and are looking for usernames to try passwords on.\r\n     *\r\n     * @param username String value of input provided by user for username\r\n     * @param password String value of input provided by user for password\r\n     * @return true on successful login, false on unsuccessful login\r\n     */\r\n    public boolean checkUser(String username, String password){\r\n        if(!hashmap.containsKey(username)) {//username is incorrect - put we might not want to alert the user to this if they're malicious\r\n            System.out.println(\"Username does not exist\");\r\n            return false;\r\n        }else{//username exists\r\n            User accessedUser = hashmap.get(username);\r\n            if(password == accessedUser.getPassword()){\r\n                System.out.println(\"Successful login\");\r\n                return true;\r\n            }\r\n            /* to use the encryption code,\r\n               byte[] salt = accessedUser.getSalt();\r\n               byte[] actualPassword = accessedUser.getPassword();\r\n               return authenticate(password, salt, actualPassword);\r\n             */\r\n            else{\r\n                System.out.println(\"Incorrect password\");\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    //Everything below this point can be moved to the User class. Some parameters may change to make more sense in that context.\r\n\r\n\r\n    /*\r\n     * As I said before, we shouldn't store plaintext passwords. One common way to implement a safer system is with a salted hash.\r\n     * We generate some random string, called a salt, and mix this with the password in some way. We then feed this salted password\r\n     * to a hash function, and save the result as the user's \"password.\" We also save the salt. When the user wants to login, repeat the\r\n     * process and check the saltedHashedPassword. By doing so, we are storing the password in a safe way with little overhead.\r\n     */\r\n\r\n    //the next 3 functions are a simple implementation of securely storing passwords I found at\r\n    //https://www.javacodegeeks.com/2012/05/secure-password-storage-donts-dos-and.html\r\n    //it could probably be improved or use a better hash function or replaced with the ability to sign in with another service (Google)\r\n    //but I will leave it for now as a first attempt\r\n    //I will also explain as I go through these functions\r\n\r\n    /* Move to User class?\r\n     *\r\n     * First step in storing a user's password securely. We generate a salt, which is a random string.\r\n     * We use SecureRandom to ensure that this value is actually random and cannot be predicted in any way.\r\n     * This salt will be combined with the user's password. This means that 2 exact passwords will not hash\r\n     * to the same value, as the random salt will make them different. We store this salt in plaintext - it does\r\n     * not need to be secret.\r\n     *\r\n     * @return a string (byte array) that is our 64 bit random salt\r\n     */\r\n    public byte[] generateSalt() throws NoSuchAlgorithmException {\r\n        // VERY important to use SecureRandom instead of just Random\r\n        SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\r\n\r\n        // Generate a 8 byte (64 bit) salt as recommended by RSA PKCS5\r\n        byte[] salt = new byte[8];\r\n        random.nextBytes(salt);\r\n\r\n        return salt;\r\n    }\r\n\r\n\r\n\r\n    /* This can stay here or move - maybe its own class\r\n     *\r\n     * This will be called after generating the salt. This will be the only time\r\n     * that part of our code touches the plaintext password. The result of this function\r\n     * is what we will store as the User's password.\r\n     *\r\n     * This function is also called to check a provided password for a match. All we do is\r\n     * salt and hash what's provided, so we can use this to compare in the next function.\r\n     *\r\n     * This password isn't really encrypted, but hashed. The reasoning for this is that\r\n     * we don't need to unencrypt the password, and we actually want to avoid providing\r\n     * a way for that to be done. So, this is a one-way operation.\r\n     *\r\n     * @param password the user's plaintext password to encrypt\r\n     * @param salt the random string used to make it harder to figure out what the password is\r\n     * @return the salted, hashed, password which we can safely store\r\n     */\r\n    public byte[] getEncryptedPassword(String password, byte[] salt)\r\n            throws NoSuchAlgorithmException, InvalidKeySpecException {\r\n        // PBKDF2 with SHA-1 as the hashing algorithm. Note that the NIST\r\n        // specifically names SHA-1 as an acceptable hashing algorithm for PBKDF2\r\n        String algorithm = \"PBKDF2WithHmacSHA1\";\r\n        // SHA-1 generates 160 bit hashes, so that's what makes sense here\r\n        int derivedKeyLength = 160;\r\n        // Pick an iteration count that works for you. The NIST recommends at\r\n        // least 1,000 iterations:\r\n        // http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf\r\n        // iOS 4.x reportedly uses 10,000:\r\n        // http://blog.crackpassword.com/2010/09/smartphone-forensics-cracking-blackberry-backup-passwords/\r\n        int iterations = 20000;\r\n\r\n        KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, iterations, derivedKeyLength);\r\n\r\n        SecretKeyFactory f = SecretKeyFactory.getInstance(algorithm);\r\n\r\n        return f.generateSecret(spec).getEncoded();\r\n    }\r\n\r\n\r\n\r\n    /* This can stay here or move\r\n     *\r\n     * This function checks the provided password against the password we have on record for the user.\r\n     * We are not storing the actual password. Instead, we store the result from getEncryptedPassword. So,\r\n     * to check a possible password against the stored one, we need to salt and hash the provided password\r\n     * and compare the 2.\r\n     *\r\n     */\r\n    public boolean authenticate(String attemptedPassword, byte[] encryptedPassword, byte[] salt)\r\n            throws NoSuchAlgorithmException, InvalidKeySpecException {\r\n        // Encrypt the clear-text password using the same salt that was used to\r\n        // encrypt the original password\r\n        byte[] encryptedAttemptedPassword = getEncryptedPassword(attemptedPassword, salt);\r\n\r\n        // Authentication succeeds if encrypted password that the user entered\r\n        // is equal to the stored hash\r\n        return Arrays.equals(encryptedPassword, encryptedAttemptedPassword);\r\n    }\r\n\r\n    /* How can we use these with our User class?\r\n        -when the user creates their account, we call generateSalt, and store the salt with their info\r\n        -we then call getEncryptedPassword with what they provided as a password, and the salt. THIS IS WHAT WE STORE AS THE PASSWORD\r\n        -when the user logs in, we call authenticate() with what they provided as a password, as well as the password and salt stored for the account\r\n        -they are trying to access\r\n     */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n     * Move to User class\r\n     *\r\n     * 1st function fired when the user forgets their credentials. This emails the user\r\n     * object the forgotID field for the user.\r\n     *\r\n     * I am assuming that the random ID is set in the user class, and that I can access it here.\r\n     *\r\n     * I am also assuming that the user can forget their username OR password. Forgetting a password means that we can still\r\n     * use the normal getUser, as we have the username, to pass as a parameter here. However, on forgetting their username, we\r\n     * can ask for their email and call getUserFromEmail() to get the user object. In either case, we'll call this function next.\r\n     *\r\n     * @param user User object to obtain email and randomID from\r\n     * @return true on successful email sent, false otherwise\r\n     */\r\n    public boolean sendRandomID(User user){\r\n        String email = user.getEmail();//email address of user\r\n        String randomID = user.getRandomID();\r\n        String body = \"Hello, this is an email from BudgetUs, sent because you forgot your login info. Enter this code to regain access: \" + randomID;\r\n        return sendEmail(body, \"Forgot Credentials\", email);\r\n    }\r\n\r\n\r\n    /*\r\n    * Move to User class\r\n    *\r\n    * This function sends the message in an email to the reciever. Majority of the code is done in 3 other files\r\n    * (Gmailsender.java, ByteArrayDataSource.java, and JSSEProvider.java), and I found most of this code on the internet\r\n    * so I will cite my sources as well. It also requires a few jar files, stored under app/build/libs. You may have to right-click\r\n    * and click \"Add as library\" in your AndroidStudio project.\r\n    *\r\n    * Network operations also require a few extra permissions, defined in AndroidManifest, and need to run on a secondary\r\n    * thread.\r\n    * @param message body of the email\r\n    * @param subject subject line of the email\r\n    * @param receiver recipient of the email\r\n    * @return true on success, false on any errors\r\n    */\r\n    public boolean sendEmail(final String message, final String subject, final String receiver){\r\n        final boolean[] ret = {true};//nested functions are weird\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    //NOTE - email login info is here, really this code should run on a server or something, where user cannot see the source code\r\n                    GmailSender sender = new GmailSender(\"budgetusemail@gmail.com\", \"budgetus123!\");//sender of email - credentials\r\n                    sender.sendMail(subject, message, \"budgetusemail@gmail.com\", receiver);//subject, body, sender, receiver\r\n                } catch (Exception e) {\r\n                    Log.e(\"SendMail\", e.getMessage(), e);\r\n                    ret[0] = false;\r\n                }\r\n            }\r\n        }).start();\r\n        return ret[0];\r\n    }\r\n\r\n    /* Move to User class\r\n\r\n     * 2nd function fired when the user forgets their username or password. This checks if\r\n     * the forgotID provided by the user matches the forgotID. We will also update the user's\r\n     * random id after this attempted match.\r\n     *\r\n     * @param id the id provided by the user attempting to login\r\n     * @param user User object to obtain real ID from\r\n     * @return true on successful match, false otherwise\r\n     */\r\n    public boolean matchForgotID(String id, User user){\r\n        boolean ret = false;\r\n        if(id == user.getRandomID()) ret = true;\r\n        user.setRandomID(Random());//in either case, we should generate a new random ID\r\n        return ret;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/budgetus/UserRecord.java	(revision 6976b305048ceaf218fde1429623f3b7a25e0294)
+++ app/src/main/java/com/example/budgetus/UserRecord.java	(date 1606164408455)
@@ -33,12 +33,17 @@
 
 public class UserRecord {
 
+    //private Context mContext; matt
     private Map<String, User> hashmap = new HashMap<String, User>(1000);
 
+    //public UserRecord (Context context){ matt
     public UserRecord (){
+        //this.mContext = context; matt
         try {
             FileProcessor fp = new FileProcessor();
             hashmap = fp.getUserMap();
+            //System.out.println(getUser("dlam15").getSchool());//prints Binghamton
+            //System.out.println(getUser("admin").getName());//prints John Doe
         }catch(Exception e){
             e.printStackTrace();
         }
@@ -50,7 +55,52 @@
     //additional functions
     //correct communication between events firing, driver class, user class
     //collision resolution vs username unavailable (see how many collisions from testing)
+    /*
+     * A function for some simple tests of hashmap, adding users, reading info, etc
+     * What I've learned:
+     *  -hashmap handles pretty much everything (hash function, collisions, expanding, etc)
+     *  -reading from a null object will crash the entire app, so we might want some checks or catches?
+     *  -security stuff works
+     *  -Derrick's database stuff works
+     */
+  /* public void test()  {
+        try{
+            byte[] salt = PasswordEncryptionService.generateSalt();
+            System.out.println("salt: " + Arrays.toString(salt));
+            byte[] pw = PasswordEncryptionService.getEncryptedPassword("2e8u13189rh12d1f3dcx]1[dq3", salt);
+            System.out.println("password: " + Arrays.toString(pw));
+            System.out.println(PasswordEncryptionService.authenticate("2e8u13189rh12d1f3dcx]1[dq3", pw, salt));
+            System.out.println(PasswordEncryptionService.authenticate("notpassword", pw, salt));
+        }
+        catch(Exception e){
+            e.printStackTrace();
+        }
+    }*/
+
 
+    /* We use this function to check if a username a new user is trying to use is valid. For
+     * it to be valid, it must not be in use by someone else. So, we just check the hashmap for the name.
+     *
+     * @param username the username the registering user wants to use and we need to check for
+     * @return true if the username is not in use, false if it is
+     */
+  /*  public boolean checkUsername(String username){
+        return !hashmap.containsKey(username);
+    }*/
+
+    /* We use this function to check if a email a new user is trying to use is valid. For
+     * it to be valid, it must not be in use by someone else. So, we just check the hashmap for the email.
+     *
+     * @param email the email the registering user wants to use and we need to check for
+     * @return true if the email is not in use, false if it is
+     */
+ /*   public boolean checkEmail(String email){
+        for(User userElement : hashmap.values()){
+            User currUser = userElement;
+            if(currUser.getEmail().equals(email)) return false;
+        }
+        return true;
+    }*/
 
     /*
      * Add a new user to the hashmap. This is triggered when the user registers.
@@ -79,6 +129,7 @@
         }
         if (hashmap.containsKey(username)) {//true if mapping for this key already exists - could be either a collision or that this username is taken
             User existingUser = hashmap.get(username);
+            //assert existingUser != null; britania
             if(existingUser.getUsername() == username){//username actually in use, otherwise its just a collision
                 System.out.println("User already exists");
                 return false;
@@ -93,7 +144,12 @@
         }
         return false;
     }
-
+    /*public boolean addUser(User newUser) { matt
+        String username = newUser.getUsername();//obtain key from username hash function
+        hashmap.put(username, newUser);
+        System.out.println("Success");
+        return true;
+    }*/
 
     /*
      * Get a user from the hashmap. Considering that all of the user objects are stored in the hashmap,
@@ -121,6 +177,7 @@
         for(User userElement : hashmap.values()){
             User currUser = userElement;
             if(currUser.getEmail() == email) return currUser;
+            //if(userElement.getEmail().equalsIgnoreCase (email)) return userElement; britania
         }
         return null;
     }
@@ -139,7 +196,11 @@
         System.out.println("User does not exist");
         return false;
     }
-
+    /*public boolean removeUser(String username){ matt
+        if(hashmap.remove(username) != null) return true;
+        System.out.println("User does not exist");
+        return false;
+    }*/
 
 
 
@@ -161,6 +222,8 @@
             return false;
         }else{//username exists
             User accessedUser = hashmap.get(username);
+            //assert accessedUser != null; britania
+            //if(accessedUser.getPassword().equals(password)){ matt
             if(password == accessedUser.getPassword()){
                 System.out.println("Successful login");
                 return true;
@@ -310,6 +373,7 @@
     public boolean sendRandomID(User user){
         String email = user.getEmail();//email address of user
         String randomID = user.getRandomID();
+        //String randomID = "randomID placeholder"; matt
         String body = "Hello, this is an email from BudgetUs, sent because you forgot your login info. Enter this code to regain access: " + randomID;
         return sendEmail(body, "Forgot Credentials", email);
     }
@@ -347,6 +411,12 @@
         }).start();
         return ret[0];
     }
+/* britania
+    public boolean sendUsername(User user){
+        String email = user.getEmail();//email address of user
+        String randomID = "123gruwguwecfcrugrb2y4i32t47vtc37";//user.getRandomID();//random id to email
+        return false;
+    }*/
 
     /* Move to User class
 
@@ -365,4 +435,28 @@
         return ret;
     }
 
+    /*
+     * This will be the function called when trying to register a user. We check the username
+     * and email fields they provide to see if they are already in use. If not, we can create the user.
+     * Otherwise, the user will have to provide different info.
+     *
+     * After this function returns true, we make a new user object with what the new user provided, and
+     * then call addUser. We will also print out which of the fields are in use (if any). We could change this to the
+     * return value to pass somewhere to tell the user.
+     *
+     * @param username the new user's desired username
+     * @param email the new user's desired email
+     * @return true if both are available, false otherwise
+     */
+   /* public boolean attemptRegister(String username, String email){ matt
+        if(!checkUsername(username)){
+            System.out.println("Username in use");
+            return false;
+        }
+        if(!checkEmail(email)){
+            System.out.println("Email in use");
+            return false;
+        }
+        return true;
+    }*/
 }
Index: app/src/main/res/layout/activity_main_dashboard.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/activity_main_dashboard.xml	(revision 6976b305048ceaf218fde1429623f3b7a25e0294)
+++ app/src/main/res/layout/activity_main_dashboard.xml	(revision 6976b305048ceaf218fde1429623f3b7a25e0294)
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    tools:context=".MainDashboard">
-
-    <TextView
-        android:id="@+id/textView"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_marginTop="146dp"
-        android:text="TextView"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintTop_toTopOf="parent" />
-</androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
